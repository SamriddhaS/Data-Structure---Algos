Tutorial Playlist : https://www.youtube.com/playlist?list=PLRKyZvuMYSIPJ84lXQSHMn8P-0J8jW5YT

1. What are flow api in kotlin ?

    Kotlin Flow is a reactive streams API built on top of Kotlin coroutines. It's designed to handle
    asynchronous streams of data that can emit multiple values over time.

    The major components of Flow are as below:

        - Flow Builder
        - Operator
        - Collector

    Flow Builder :
        In simple words, we can say that it helps in doing a task and emitting items.
        Sometimes it is just required to emit the items without doing any task, for example,
        just emit a few numbers (1, 2, 3). Here, the flow builder helps us in doing so.
        We can think of this as a Speaker. The Speaker will think(do a task) and speak(emit items).

    Operator :
        The operator helps in transforming the data from one format to another.
        We can think of the operator as a Translator.
        Operators are more than this actually, using the operator, we can also
        provide the thread on which the task will be done.

    Collector :
        The collector collects the items emitted using the Flow Builder which are transformed by the operators.
        We can think of a collector as a Listener. Actually, Collector also comes under the
        operator which is known as Terminal Operator. The collector is a Terminal Operator.
        For now, we will skip the Terminal Operator as that is not needed for this blog on Flow API.

    Code Example :

        flow {
            (0..10).forEach {
                emit(it)
            }
        }.map {
            it * it
        }.collect {
            Log.d(TAG, it.toString())
        }

        flow { }    ->	Flow Builder
        map { }     ->	Operator
        collect {}  ->	Collector


2. Different types of flow builder ?

    There are 4 types of flow builders:

    - flowOf(): It is used to create flow from a given set of items.

        flowOf(4, 2, 5, 1, 7)
        .collect {
            Log.d(TAG, it.toString())
        }

    - asFlow(): It is an extension function that helps to convert type into flows.

        (1..5)
        .asFlow()
        .collect {
            Log.d(TAG, it.toString())
        }

    - flow{}:

        The flow {} builder creates a cold, sequential flow. It's a fundamental builder used
        for generating data streams where items are produced one after another. The producer
        (the code inside flow {}) is tightly coupled with the consumer (the collector). When
        the collector is ready to receive an item, the emit() function is called, which
        suspends until the item is consumed. This ensures an efficient, pull-based model
        and is ideal for straightforward, single-source data streams.

        flow {
            (0..10).forEach {
                emit(it)
            }
        }
        .collect {
            Log.d(TAG, it.toString())
        }

    - channelFlow{}:

        The channelFlow {} builder creates concurrent flow using an internal channel.
        It's designed for scenarios where the producer needs to emit items asynchronously,
        potentially from multiple sources, without waiting for the collector to be ready.
        It uses the send() function, which adds an item to the channel and can proceed immediately.
        This decouples the producer from the consumer, making it a powerful tool for bridging event-driven or
        callback-based APIs into a flow.

        Code Example :

        val service1 = DataService()
        val service2 = DataService()

        val combinedFlow = channelFlow {
            // Launch a coroutine to listen to the first service
            val job1 = launch {
                service1.setCallback { data ->
                    trySend(data)
                }
            }

            // Launch a coroutine to listen to the second service
            val job2 = launch {
                service2.setCallback { data ->
                    trySend(data)
                }
            }

            // Keep the channel open until the flow is cancelled
            awaitClose {
                job1.cancel()
                job2.cancel()
                println("All listeners cancelled")
            }
        }

        // Start emitting data from the services
        service1.startEmitting()
        service2.startEmitting()

3. What are Terminal Operators in Kotlin Flow ?

    In Kotlin Flow, terminal operators are functions that start the collection of a flow.
    They are the final step in a flow pipeline, triggering the execution of all intermediate
    operators and consuming the values emitted by the upstream flow. Without a terminal operator,
    a flow is just a cold stream of data that does nothing.

    - collect is the most basic terminal operator. It suspends the coroutine until the flow completes,
    processing each value as it's emitted.

        val numbersFlow = flowOf(1, 2, 3)
        numbersFlow.collect { number ->
            println("Collected value: $number")
        }

        Output:
        Collected value: 1
        Collected value: 2
        Collected value: 3

    - first collects the first value emitted by the flow and then cancels the collection.
    It's useful when you only need one result.

        val numbersFlow = flowOf(1, 3, 4, 5, 6)
        val firstEven = numbersFlow
            .filter { it % 2 == 0 }
            .first() // Stops here after finding 4
        println("The first even number is: $firstEven")

        Output:
        The first even number is: 4

    - reduce is an aggregation operator. It applies a cumulative operation to the flow's
    values and returns a single final result.

        val numbersFlow = flowOf(1, 2, 3, 4)

        val sum = numbersFlow.reduce { accumulator, value ->
            accumulator + value
        }

        Output:
        The sum is: 10

    - toList collects all values from the flow into a single List.

        val namesFlow = flowOf("Alice", "Bob", "Charlie")
        val nameList = namesFlow.toList()
        println("The list of names is: $nameList")

        Output:
        The list of names is: [Alice, Bob, Charlie]


4. Cold Flow vs Hot Flow :

                Cold Flow	                                         Hot Flow
    It emits data only when there is a collector.	It emits data even when there is no collector.
    It does not store data.	                        It can store data.
    It can't have multiple collectors.	            It can have multiple collectors.

    In Cold Flow, in the case of multiple collectors, the complete flow will begin from the beginning for
    each one of the collectors, do the task and emit the values to their corresponding collectors.
    It's like 1-to-1 mapping. 1 Flow for 1 Collector. It means a cold flow can't have multiple
    collectors as it will create a new flow for each of the collectors.

    In Hot Flow, in the case of multiple collectors, the flow will keep on emitting the values,
    collectors get the values from where they have started collecting. It's like 1-to-N mapping.
    1 Flow for N Collectors. It means a hot flow can have multiple collectors.

    The most common types of hot flows are StateFlow and SharedFlow.

5. StateFlow and SharedFlow :

        StateFlow	                                                          SharedFlow

    Hot Flow	                                                    Hot Flow

    Needs an initial value and emits it as soon                     Does not need an initial value so does
    as the collector starts collecting                              not emit any value by default.

    val stateFlow = MutableStateFlow(0)	                            val sharedFlow = MutableSharedFlow<Int>()

    Only emits the last known value.                	            Can be configured to emit many previous values using
                                                                    the replay operator.

    It has the value property,                                      It does not have the value property. It
    we can check the current value at any point of time.            doesn't store any value, so if new value is not
    Even if its not emitting new value the last emitted             getting emitted the collector will not get any
    value will be stored.                                           values.

    It does not emit consecutive repeated values.                   It emits all the
    It emits the value only when it is distinct from                values and does not care about the distinct from
    the previous item.	                                            the previous item. It emits consecutive repeated
                                                                    values also.


    Similar to LiveData except for the Lifecycle                    Not similar to LiveData.
    awareness of the Android component.
    We should use repeatOnLifecycle scope with StateFlow
    to add the Lifecycle awareness to it,
    then it will become exactly like LiveData.


6. StateFlow vs LiveData :

    - LiveData does all the transformations/operations on main thread.
      But for flow we can perform the transformations/operations on any thread using flowOn() property.

    - LiveData is life cycle aware using the lifecycle owner class.
      Flows are not life cycle aware, we can make it lifecycle aware by using repeatOnLifeCycle scope.


7. What is Reducer ?
    A reducer is a function that combines (reduces) multiple emitted values from a Flow into a single value.
    In Kotlin Flow, the function that performs this reduction is called reduce.

    - Unlike collect (which runs for each emission), reduce only returns once, after the flow completes.
    - If the flow is empty, reduce will throw NoSuchElementException.

    Use reducers when:
        - You want to combine all emitted items into one final value (like sum, max, average, etc.)
        - You want to collect results only once, after processing all emissions.
        - You are performing aggregation or summary operations.

    Example :
    val namesFlow = flowOf("Alice", "Bob", "Charlie")
    val combined = namesFlow.reduce { acc, name ->
        "$acc, $name"
    }
    println(combined)

    Output : Alice, Bob, Charlie

8. Long-running tasks in parallel with Kotlin Flow
    Link: https://outcomeschool.com/blog/long-running-tasks-in-parallel-with-kotlin-flow

9. Retry Operator in Kotlin Flow
    Link: https://outcomeschool.com/blog/retry-operator-in-kotlin-flow

10. Retrofit with Kotlin Flow
    Link: https://outcomeschool.com/blog/retrofit-with-kotlin-flow

11. Room Database with Kotlin Flow
    Link: https://outcomeschool.com/blog/room-database-with-kotlin-flow

12. Kotlin Flow Zip Operator for Parallel Multiple Network Calls
    Link: https://outcomeschool.com/blog/kotlin-flow-zip-operator-parallel-multiple-network-calls

13. Instant Search Using Kotlin Flow Operators
    Link: https://outcomeschool.com/blog/instant-search-using-kotlin-flow-operators

14. callbackFlow â€“ Callback to Flow API in Kotlin
    Link: https://outcomeschool.com/blog/callback-to-flow-api-in-kotlin

15. Exception Handling in Kotlin Flow
    Link: https://outcomeschool.com/blog/exception-handling-in-kotlin-flow

16. Unit Testing ViewModel with Kotlin Flow and StateFlow
    Link: https://outcomeschool.com/blog/unit-testing-viewmodel-with-kotlin-flow-and-stateflow