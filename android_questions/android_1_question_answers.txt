1. How does findViewById work internally ?
Ans :
 In the XML file when we add an element and set the properties to it we only set the values for these properties,
 now for each element, there is a class that draws it at the screen, this class has attributes with the
 same names of the properties in the XML file now using algorithms of read-write from files these values
 from the XML file are transmitted to the java file (class) of the element, and then the class draws that element on the screen.
 Before the class of the element draws it, there is a superclass of all elements,
 the parent for all of them it is called View (every element in the activity is called view) this class has the basic
 properties of all elements and this class is the one which the properties from the XML file will be transmitted to it.
 Method findViewById() returns an object of View type, this object holds the properties values then we need to cast it to the specific element, for example, TextView which is a class to draw the text view this class and all elements' classes are
 subclasses of View class so what we do is downcasting, that when this method returns the object of View type we downcast it to the element class
 How it finds the properties? it finds the properties of the element using the id if the tag in the XML file first it searches in t
 he XML file for the tag that holds the element's name and then it looks at the id if it is the id which it wants then it takes it
 otherwise it searches for another tag (with the same element name).
 We give it the id by this approach. there is a class is called R (resources),
 this class has nested classes (id, string, colors) these classes have attributes from the same type and hold specific values,
 for instance, the id class it has attributes that stores each id of each element in the XML file,
 so when we want to give the method findViewById() the id we go to this class and tell it to enter id class and choose the id of the element we want.
 And the process goes that it enters to the XML file and look for the element that has this id and it takes the properties and passes them to the
 class view object and when it returns the object we downcast it to the element's class that we want to draw it and deal with it.
 Thread : https://stackoverflow.com/questions/35357734/how-does-findviewbyid-work
 Very good explanation : https://medium.com/@sm3.saurabhmishra/android-deep-dive-findviewbyid-547177fbe880


2. What is AIDL in android ?

And : https://developer.android.com/develop/background-work/services/aidl

‚úÖ What is AIDL (Android Interface Definition Language)?

AIDL is Android‚Äôs way to define interfaces for Inter-Process Communication (IPC) between components running in different processes.
‚ú® Think of it like:

    AIDL is a contract between two Android components ‚Äî usually from different apps ‚Äî that want to talk to each other securely and efficiently.

For example:

    App A wants to get data from a service running in App B (e.g., getting the location, playing music, managing files).

    Android doesn't allow direct memory access across processes.

    So objects must be marshalled (serialized) and unmarshalled safely across process boundaries. AIDL handles this behind the scenes.

üìå When Should You Use AIDL?

Use AIDL if:

    You‚Äôre exposing a bound service to clients from different apps (processes).

    You want to handle multithreading in the service.

    You need high-performance, bidirectional communication (like callbacks, or data streams).

Don‚Äôt use AIDL if:

    You only need IPC within the same app ‚Üí just use Binder directly.

    You don‚Äôt need multithreading ‚Üí use Messenger.

üß† Key Concepts & Things to Remember
Concept	Description
.aidl File	Defines the interface. Like IRemoteService.aidl.
Stub Class	Generated automatically; you extend this to implement the interface.
Binder	Android's base class for inter-process communication.
onBind()	Returns the implementation of the Stub to clients.
asInterface()	Used on the client side to get the usable object from the IBinder.
in, out, inout	Directional tags for complex types (not needed for primitives).
oneway	Marks methods as asynchronous/non-blocking.
Threading	IPC methods run on a Binder thread pool, not UI thread ‚Äî always ensure thread safety!
üì¶ Real-world Example Use Cases

Here are some real Android system-level examples where AIDL is used ‚Äî talk about these in your interview for a strong impression.
1. Android System Services

Many system services are defined via AIDL. For example:
üß≠ LocationManagerService

    You call LocationManager to get GPS coordinates.

    Under the hood, it uses ILocationManager.aidl to communicate with the system service running in another process.

    This allows apps to request location updates from the centralized system process securely.

üéß Media playback

    IMediaPlayerService.aidl & IMediaSession.aidl

    Used when apps communicate with the system's audio playback pipeline ‚Äî like in Spotify, YouTube, or Google Play Music.

2. Play Store

    Google Play Services uses AIDL to expose APIs (e.g., license verification, in-app billing).

    Apps like your game can use IInAppBillingService.aidl to talk with the Play Store securely and perform in-app purchases.


Two apps:

    App A (Client) ‚Äì Wants to get data

    App B (Service) ‚Äì Offers the data via an AIDL interface

üìä Diagram ‚Äì AIDL IPC Flow

[App A: Client]                                 [App B: Service]
----------------                                 ----------------
1. IRemoteService.aidl       --->               1. IRemoteService.aidl
2. bindService()             --->               2. onBind() returns Stub
3. onServiceConnected()      <---               3. Stub is sent as IBinder
4. call remote method        --->               4. Method runs in App B's thread pool
5. result returned           <---               5. Service processes and sends response

Both apps must include the same .aidl file in src/main/aidl.


- What is a Bound Service, and how does AIDL use it?
üìå Bound Service:

A bound service is a service that allows components (clients) to bind to it and interact via a persistent connection ‚Äî like calling methods, receiving callbacks, etc.
ü§ù Relationship with AIDL:

AIDL is one way to define the interface that clients can use when they bind to the service. It‚Äôs especially used when:

    The client is from a different app/process

    You need complex or high-performance IPC

Service Lifecycle in Bound Service:

    onBind() is triggered when a client binds.

    It returns an IBinder object (Stub generated from AIDL).

    The client uses this to call remote methods.



3. What is Binder Class ?
Answer :
In Android, the Binder class is a crucial part of the framework that enables Inter-Process Communication (IPC).
Think of it as the secure and efficient messaging system for Android processes.

In simple terms:

    Android applications and system components generally run in their own isolated memory spaces,
    in separate processes, for security and stability.

    When one of these processes needs to interact with another ‚Äì whether it's an app talking to a system service,
    or even two parts of the same
    app running in different processes ‚Äì they cannot directly share memory or call functions on each other.
    The Binder mechanism provides the low-level foundation for these separate processes to communicate.
    It allows an object in one process to call methods on an object in another process, making it feel almost
    like a local method call, despite the process boundary.

It's important to note that as Android developers, we rarely interact with the Binder class directly.
Instead, we leverage higher-level Android APIs that utilize Binder under the hood.
The most common ways we indirectly use Binder are through:

    Android's Core System Services: Almost every interaction with the Android OS relies on Binder.

    Bound Services: When you create your own Service that other components (potentially in different processes) can bind to and interact with.

    AIDL (Android Interface Definition Language): This is a tool that generates the necessary Binder boilerplate code for you, allowing you to define an interface for cross-process communication.

Here are a few realistic examples of where Binder is fundamental:

    Launching an Activity: When your app calls startActivity() to launch another activity (even one within your own app, if it's in a different process, or an activity from another app), your app's process uses Binder to communicate with the ActivityManagerService (which lives in the Android system server process).
    It's the Binder that transmits the intent and other launch parameters, and facilitates the response back to your app.

    Displaying a Notification: When your app creates and publishes a notification using NotificationManager.notify(),
    your app's process isn't directly drawing the notification on the screen.
    Instead, it uses Binder to send the notification data (icon, text, pending intent, etc.) to the NotificationManagerService in the system process.
    This system service then handles the actual display of the notification in the status bar and notification shade.

    Accessing System Services (like Location): When your app requests your current location using LocationManager.requestLocationUpdates(),
    your app (Process A) doesn't directly access the GPS hardware.
    It's the Binder that transmits your request to the Location Manager Service (running in the system server, Process B).
    The service then gets the location and uses Binder again to send that data back to your application.

In essence, while we interact with high-level APIs like startActivity() or NotificationManager,
it's the robust and efficient Binder framework that's always working behind the scenes,
enabling all this crucial cross-process communication in Android."

4. Bound Service ?
Video : https://www.youtube.com/watch?v=_xNkVNaC9AI

A Bound Service in Android is a type of service that provides a client-server interface that
allows components (like activities or other services), whether they are in the same process or a different process,
to bind to the service, send requests, receive results, and even perform IPC (Inter-Process Communication) if the client
and service are in separate processes.

Key Characteristics:

    Client-Server Interaction: It allows clients to directly interact with the service, calling methods on the service instance.

    Lifecycle Tied to Clients: The service is created when the first client binds to it and is destroyed when the last client
    unbinds (unless it's also a started service).

    IPC Mechanism: It's the primary way to enable IPC between your own app's components, especially when using AIDL,
    which relies heavily on Binder for the underlying communication.

    Returns an IBinder: When a client binds, the service's onBind() method returns an IBinder object.
    This IBinder is the communication channel that the client uses to interact with the service.
    This is where Binder (specifically, an object implementing IBinder) comes into play.

A Simple, Realistic Example: A Music Player App

Imagine you're building a music player. You want music to keep playing even if the user navigates away from the main UI (your Activity).

    The Service: You'd create a MusicPlaybackService that runs in the background.
    This service contains all the logic for playing, pausing, skipping songs, etc.

    The Activity (Client): Your main MainActivity (the UI) needs to tell the MusicPlaybackService to play a song or pause it.

How a Bound Service solves this:

    Your MainActivity calls bindService() to connect to the MusicPlaybackService.

    The MusicPlaybackService implements an onBind() method which returns a custom IBinder object (often a Binder subclass you define,
    or one generated by AIDL). This IBinder contains methods like play(), pause(), getNowPlayingSong().

    Once the MainActivity receives this IBinder object (in its onServiceConnected() callback),
    it can then directly call methods like serviceBinder.play() or serviceBinder.getNowPlayingSong() as if it were calling a local object.

    The MusicPlaybackService will continue playing music in the background. If the user closes the MainActivity, it can unbind from the service,
    but the service might continue running if it was also started (e.g., to keep playing music in the notification). If it's only bound and
    the last client unbinds, the service shuts down.

In essence, a Bound Service provides a direct, programmatic interface for other components to connect to and control a background
operation, making it ideal for features like media playback, network downloads that need status updates, or any scenario requiring
ongoing interaction with a background process."

5. What Happens When You Click on an App in Android ?
Answer :
=> https://dev.to/nikhildupally/what-happens-when-you-click-on-an-app-in-android-a-deep-dive-4dk4
    1. The Launcher Gets to Work

    When you tap an app icon, the Launcher (your home screen app) picks up the touch event. Here‚Äôs what happens next:

        Touch Processing: The system detects your touch through Android‚Äôs input framework and determines which icon was pressed.

        Intent Creation: The launcher creates an Intent that tells the system which app you want to open.

        Communicating with the System: It sends a request to the Activity Manager Service (AMS) via Binder IPC to start the app.

    2. Checking If the App is Already Running

    The Activity Manager Service (AMS), which is part of the Android system, now takes over and decides what to do next:

        Is the app already open? If the app is already running, AMS just brings it to the foreground.

        If not, find the process: AMS checks if the app‚Äôs process is active.

        Starting fresh: If the process isn‚Äôt running, AMS requests Zygote to start a new instance of the app.

    3. Zygote: The Process Factory

    Zygote is a special system process responsible for launching apps efficiently. Here‚Äôs what it does:

        Receiving the request: Zygote gets a command from AMS via a socket message.

        Forking a new process: Instead of creating a whole new process from scratch, Zygote forks itself to make a lightweight copy. This saves time and resources.

        Starting the Android Runtime (ART): The new process is now ready to load the app.

    4. Initializing the App

    Now that the app‚Äôs process is up and running, the Android Runtime (ART) takes over:

        Loading classes and resources: The app‚Äôs code and assets are loaded into memory.

        Calling main() method: The entry point of the app (ActivityThread.main()) is executed, setting up the main thread and event loop.

        Creating the Application object: The app‚Äôs Application class (defined in AndroidManifest.xml) is instantiated, and onCreate() is called.

    5. Creating and Rendering the First Screen

    After the app is initialized, the first activity is launched:

        AMS tells the app process to start an activity.

        ActivityThread handles the launch: The activity is created, and lifecycle methods (onCreate(), onStart(), onResume()) are executed.

        Rendering the UI: The app‚Äôs interface is drawn using ViewRootImpl and SurfaceFlinger, which handle OpenGL rendering and sending the image to your screen.

    6. Your App Appears!

The final step is making sure you see the app on your display:

    The UI updates sync with the screen‚Äôs refresh rate using Choreographer.

    SurfaceFlinger combines all the visual elements and sends the final frame to your phone‚Äôs display.

    Your app is now ready to use! üéâ


8. How to create LRU cache ?

    What is LRU Cache?

    An LRU (Least Recently Used) Cache is a fixed-size cache that stores data, prioritizing the
    removal of the least recently accessed items when the cache reaches its capacity. It ensures
    that frequently used data remains quickly accessible.

    Where are LRU Caches Used in Android Apps?

    LRU Caches are predominantly used in Android apps for efficient memory management and performance optimization,
    particularly for resources that are frequently accessed but also consume significant memory.

    Most Common Use Cases of LRU Cache in Android Apps:

        Image Caching: This is the most common use case. Images loaded from the network or disk are stored in an LRU cache (e.g., in RAM) to prevent re-downloading or re-decoding them when they are viewed again (e.g., in a RecyclerView during fast scrolling).

        Bitmap Caching: Specifically for Bitmap objects, which are memory-intensive. An LruCache<String, Bitmap> is fundamental for smooth UI experience when displaying many images.

        Data Caching (API Responses): Caching frequently accessed data from network API calls (e.g., user profiles, product lists, configuration data) to reduce network requests and load times.

        RecyclerView Data Pre-fetching/Caching: Caching data for items in a RecyclerView that are just off-screen to improve the perceived loading speed during scrolling.

    How to Implement Your Own LRU Cache?

    In Android, the most straightforward way to implement your own LRU Cache is by using the android.util.LruCache class.

    Key Implementation Steps:

        Instantiate LruCache: Create an instance of LruCache, specifying the maximum size (e.g., in kilobytes for images, or number of items for data).
        Java

    // Example for caching Bitmaps, with a max size of 1/8th of app's max memory
    final int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024);
    final int cacheSize = maxMemory / 8; // Use 1/8th of the available memory for cache

    LruCache<String, Bitmap> bitmapCache = new LruCache<String, Bitmap>(cacheSize) {
        @Override
        protected int sizeOf(String key, Bitmap bitmap) {
            // Return the size of the bitmap in kilobytes
            return bitmap.getByteCount() / 1024;
        }
    };

    Add to Cache (put): When data is loaded or generated, add it to the cache.
    Java

    // bitmap to be cached
    String key = "image_url_or_id";
    Bitmap loadedBitmap = ...;
    if (loadedBitmap != null) {
        bitmapCache.put(key, loadedBitmap);
    }

    Retrieve from Cache (get): Before loading data, check if it's already in the cache.
    Java

        Bitmap cachedBitmap = bitmapCache.get(key);
        if (cachedBitmap != null) {
            // Use cachedBitmap
        } else {
            // Load the bitmap (e.g., from disk or network)
            // ... then put it into the cache
        }

    Override sizeOf (Crucial for custom objects): For objects like Bitmaps, you must override sizeOf() to tell the cache how to calculate the size of each item (e.g., in bytes or kilobytes), so it can correctly manage its capacity. For simple objects like Strings, sizeOf might just return 1 to count items.
    This LruCache class handles the LRU eviction policy (removing the least recently used item when full) automatically, making implementation straightforward.

9. How view models work internally to preserve data accorss configuration changes ?

    Easy to understnad explaintaion : https://www.droidcon.com/2025/01/13/understanding-viewmodel-persistence-across-configuration-changes-in-android/
    VeryDeep explaintaion : https://proandroiddev.com/how-viewmodel-works-under-the-hood-52a4f1ff64cf

    ViewModelStore: Every Activity or Fragment that uses a ViewModel has a ViewModelStore associated with it.
    This ViewModelStore is where the ViewModel objects are actually held.

    ViewModelProvider: When you request a ViewModel (e.g., ViewModelProvider(this).get(MyViewModel::class.java)),
    the ViewModelProvider does the following:

        It checks the ViewModelStore associated with the current scope (Activity or Fragment) to see if a
        MyViewModel instance already exists.

        If an instance exists, it returns the existing instance.

        If no instance exists, it creates a new MyViewModel instance and puts it in the ViewModelStore.

    Surviving Configuration Changes:

        When a configuration change occurs (like a screen rotation), the Activity or Fragment is destroyed and recreated.

        However, the ViewModelStore is not destroyed. It is managed by the Android framework and is tied to the scope's lifecycle in a special way.

        When the new Activity or Fragment is created, it gets the same ViewModelStore instance that was used before the configuration change.

        The ViewModelProvider is then called again. It checks the ViewModelStore, finds the existing MyViewModel instance, and returns it.

        This means the ViewModel object and all the data it holds (e.g., a list of users, a network request result) remain in memory and are not lost.

    The Role of onCleared(): The onCleared() method is called when the ViewModelStoreOwner (the Activity or Fragment) is finally finished.
    This happens when the Activity is permanently destroyed (e.g., the user presses the back button and exits the app) or the Fragment is
    detached and removed. This is the signal for the ViewModelStore to clear out the ViewModel objects.
    You can use this method to release resources (e.g., cancel a long-running network request).

In essence, the ViewModel is not a magic black box. It's an object stored in a special container (ViewModelStore) that is
designed to outlive the lifecycle of its associated Activity or Fragment during configuration changes. The ViewModelProvider acts as the gatekeeper,
ensuring that the same instance is returned to the new Activity or Fragment after a configuration change.
This simple but powerful pattern prevents data loss and simplifies the development of robust and responsive Android applications.


10. How FCM Push notificatinos system work internally ?

    Amazing Explanation : https://blog.clix.so/how-push-notification-delivery-works-internally/


11. What are memory leaks ? How to detect ?
    A memory leak occurs when an object is no longer needed but still has active references,
    preventing the garbage collector from reclaiming its memory.
    In Android, this often happens when an Activity or Fragment is destroyed,
    but a background task or static reference continues to hold onto it.

    1. Android Studio Profiler (Built-in)
        - Select Memory.
        - Look for : Continuous increase in memory usage.
        - Objects that never get released after activity is closed.
        - Great for visual tracking.

    2. LeakCanary (Library)
        - Most popular leak detection tool.
        - Automatically detects and reports leaks in debug builds.
        - Gives a stack trace of what is leaking and why.

    3. Heap Dumps
        - Take heap dump from Android Studio ‚Üí analyze with MAT (Memory Analyzer Tool).
        - Advanced but gives deep insights.

    4. Logs & StrictMode
        - StrictMode can catch certain leaks like leaked SQLite cursors or closable resources.

12. how to avoide memory leaks ?

    1. Follow "Own and Release" Principle
        - Own: If your class creates or registers something (listeners, receivers, resources), you must also release/unregister it.
        - E.g., Unregister a BroadcastReceiver in onStop() if registered in onStart().

    2. Favor Lifecycle-Aware Components
        - Use ViewModel, LiveData, Flow, or LifecycleOwner.
        - These automatically handle cleanup when lifecycle ends.

    3. Avoid Memory-heavy Static Singletons
        - If using a Singleton, never store an Activity or View reference in it.
        - Only use applicationContext or lightweight objects.

    4. Profile Early and Regularly
        - Use LeakCanary during development.
        - Regularly check heap dumps before release.

13. Android Apk Creation process ?
    Detailed Explanation Blog : https://medium.com/androiddevnotes/the-internals-of-android-apk-build-process-article-5b68c385fb20

    Step 1: Compilation (Java/Kotlin ‚Üí .class files)

        - The Android app source code is usually in Java/Kotlin.
        - Kotlin files are first compiled into Java bytecode by the Kotlin compiler.
        - The Java compiler (javac) converts .java files into .class files.
        - These .class files are not directly runnable on Android because Android uses the ART (Android Runtime), not the JVM.
        - Tools used: javac (Java compiler), kotlinc (Kotlin compiler)

    Step 2: DEX Conversion (.class ‚Üí .dex)

        - Android uses DEX (Dalvik Executable) files, optimized for mobile devices.
        - The D8/R8 compiler takes all .class files and merges them into .dex files.
        - R8 also performs:
            - Code shrinking (removing unused code)
            - Obfuscation (renaming classes/methods for security)
            - Optimization
        - Output: One or more .dex files inside a folder like build/intermediates/dex/.

        ART over Dalvik :
            Since Android 4.4, Android migrated to ART, the Android runtime from Dalvik.
            This execution environment executes .dex as well.
            The benefit of ART over Dalvik is that the app runs and launches faster on ART,
            this is because DEX bytecode has been translated into machine code during installation,
            no extra time is needed to compile it during the runtime.

            Even though dalvik was replaced as the default runtime, dalvik bytecode format is still in use (.dex)

            In Android version 7.0, JIT came back. The hybrid environment combining features from both a
            JIT compiler and ART was introduced.

    Step 3: Resource Compilation (res ‚Üí .arsc)

        - Your app has resources like layouts (.xml), images, strings, etc.
        - The AAPT2 (Android Asset Packaging Tool v2) does:
            - Compile XML files into a binary form.
            - Generate R.java (or R.class) to allow type-safe resource access in code.
            - Create a resources.arsc file containing compiled resources.
        - Assets in the /assets folder are directly copied as-is.
        - Example: res/layout/activity_main.xml ‚Üí binary XML inside APK

    Step 4: Packaging (Merge DEX + Resources ‚Üí APK)

        - The APK Packager now combines:
            - .dex files
            - resources.arsc
            - Compiled resources
            - Assets
            - AndroidManifest.xml (compiled)
        - The result is an unsigned APK (a simple zip file with a .apk extension).
        - Tool used: AAPT2 + Gradle‚Äôs internal packaging tasks.

    Step 5: Signing the APK

        - Android requires all apps to be digitally signed.
        - Signing ensures:
            - Integrity (APK is not tampered with)
            - Identity of the developer
        - apksigner tool applies a cryptographic signature using a keystore.
        - Without signing, the APK cannot be installed on a device.

    Step 6: Alignment (zipalign)
        - Final optimization step.
        - zipalign aligns data in the APK to 4-byte boundaries for faster memory access and reduced RAM usage.

    App Bundles (AAB) :
        - Instead of generating a single fat APK, Google Play now prefers AAB.
        - AAB contains modular APKs (like split APKs for different screen densities, architectures).
        - Play Store generates optimized APKs for each device dynamically.
        - Uses BundleTool internally.

14. Apk vs Bundle :

    Why APKs are Bigger :

    A traditional APK must include:
        - All CPU architectures: ARMv7, ARM64, x86, etc.
        - All screen densities: mdpi, hdpi, xhdpi, xxhdpi, etc.
        - All languages/locales: English, Spanish, Hindi, etc.

    Example:
        - If your app supports 5 languages √ó 3 ABIs √ó 4 screen densities ‚Üí
        - One huge APK ships all these combinations, even though any single user needs just one combination.

    How AAB Solves This :

    AAB introduces modularization. When you upload an .aab to Play Store:
    It contains:
        - Base module ‚Üí core code/resources needed for every install.
        - Configuration splits ‚Üí separate, optional chunks for specific languages, ABIs, screen densities, etc.
        - Dynamic feature modules ‚Üí optional app features downloaded on-demand.

    Google Play + BundleTool analyzes a user‚Äôs device and builds a custom APK set with only what‚Äôs needed.

    Example:
        For a user with:
            - ARM64 CPU
            - xxhdpi screen
            - English locale

        Google Play delivers:
            - Base APK + English language split + ARM64 split + xxhdpi split
            - No extra resources for other CPUs, screens, or languages.

    Limitations of AAB :
        - Cannot sideload directly (you must convert AAB to APK using BundleTool for local installs).
        - Only supported fully via Google Play or Play-enabled stores.

15. WebRTC :
    Source Blog : https://getstream.io/blog/communication-protocols/
    https://github.com/GetStream/webrtc-android

    WebRTC (Web Real-Time Communication) is an open-source project that enables real-time, peer-to-peer
    communication directly between browsers or devices.
        - It supports audio, video, screen sharing, and data transfer.
        - Unlike WebSockets or gRPC, once the connection is established, data can flow directly
        between devices without passing through a server, reducing latency.
        - It's widely used in apps like Google Meet, Zoom, WhatsApp video calls, and multiplayer gaming.

    How WebRTC Works

    Setting up a WebRTC connection is complex because browsers/devices are often behind firewalls or NATs.
    The process involves several steps and components:

    1. Signaling (Initial Handshake)

        - WebRTC does not define its own signaling mechanism.
        - Signaling is how two peers discover each other and exchange connection information.
        - Typically done using WebSockets, but it could also be via REST APIs, email, or even manual exchange.
        - Data exchanged includes SDP (Session Description Protocol) which contains:
            - Media formats (audio/video codecs, resolutions)
            - Networking details
            - ICE candidates (possible connection routes).

    2. NAT and STUN Servers

        Most devices are behind NAT (Network Address Translation), which hides private IP addresses.
        - A STUN server helps devices discover their public IP and port mapping.
        - This allows one peer to know how it can be reached by another peer directly.
        - Works for most NAT types, except Symmetric NAT (most restrictive).

    3. TURN Servers (Fallback Option)

        - If direct P2P fails (e.g., both devices behind symmetric NATs), a TURN server relays the data between peers.
        - TURN adds latency and cost but ensures the connection works.

    4. ICE (Interactive Connectivity Establishment)

        - ICE is a framework that combines STUN and TURN to find the best route between two peers.
        - It gathers multiple possible network paths (called ICE candidates) and selects the optimal one.

    5. Peer-to-Peer Connection

        - Once peers exchange SDP and ICE candidates, a direct connection is established:
        - Audio/video streams and data are exchanged in real time.
        - If direct connection isn‚Äôt possible, traffic is routed via TURN.

    Advantages of WebRTC :
        - Low latency ‚Äì ideal for real-time voice/video.
        - Peer-to-peer data transfer ‚Äì reduces server load and bandwidth cost.
        - Built-in browser support ‚Äì no plugins needed, APIs available in all modern browsers.
        - Supports rich features ‚Äì screen sharing, file transfer, video conferencing.

    Drawbacks of WebRTC :

        - Complex to set up ‚Äì requires STUN/TURN servers and a signaling mechanism.
        - No built-in signaling ‚Äì must be implemented separately (often with WebSockets).
        - Scalability challenges ‚Äì group calls may require additional infrastructure like SFU/MCU servers.
        - Relies on network conditions ‚Äì poor connectivity can degrade call quality.

16. WebSocket :

    What is a Socket Connection?

    - A socket represents one endpoint of a two-way communication channel between a client and a server.
    - WebSocket, built on top of TCP, provides full-duplex communication, meaning both client and server
    can send and receive data simultaneously over a single persistent connection.
    - Commonly used for real-time apps like chat systems, live sports updates, multiplayer games, or stock tickers.

    How WebSockets Work :

    1. Handshake (HTTP Upgrade)
        - The connection starts as an HTTP request.
        - The client sends an Upgrade header to switch the protocol to WebSocket.
        - Example: GET /chat HTTP/1.1
                   Host: example.com
                   Upgrade: websocket
                   Connection: Upgrade

    2. Persistent Connection
        - Once upgraded, a single TCP connection remains open, allowing both sides to exchange messages freely.

    3. Bi-directional Data Flow
        - Any type of data (text or binary) can be sent.
        - The connection stays alive until explicitly closed by the client or server.

    Key Features

        - Real-time, low-latency messaging.
        - Lightweight compared to polling ‚Äì no repeated HTTP requests.
        - Simple to implement ‚Äì supported by all modern browsers.
        - Flexible ‚Äì no strict data format required.

    Limitations

        - No built-in multiplexing (each browser tab = separate connection).
        - Must manually handle reconnections, load balancing, and failover.
        - Less efficient for large file transfers or video/audio streaming compared to WebRTC.


17. When to choose WebRTC vs WebSokets

    When to Choose WebRTC
        - You need real-time voice/video streaming.
        - P2P is important to reduce server bandwidth costs.

    Applications like:
        - Video conferencing
        - Live streaming
        - Peer-to-peer file transfer
        - Multiplayer games requiring very low latency.

    When to Choose WebSockets ?

    - You need real-time messaging but not complex media handling.
    - All data should pass through a centralized server for control/security.

    Simpler implementation, e.g.:
        - Chat apps
        - Real-time dashboards
        - Live sports scores
        - Stock trading tickers.

18. XMPP (Extensible Messaging and Presence Protocol) :
    What it is:

    XMPP is an open high-level XML-based messaging protocol built on top of TCP/WebSockets, designed for real-time communication.
    Originally created for instant messaging (like early Google Talk and WhatsApp‚Äôs original backend).
    It uses TCP as the transport layer and often runs over HTTP or TLS for encryption.

    It provides built-in semantics for chat, including:
        - Presence (online/offline status)
        - Message routing
        - Group chat
        - Delivery acknowledgments
        - Offline message storage

    Analogy:
    XMPP is like email for real-time chat, where rules, formats, and routing are standardized.

    Key Characteristics:
        - Standardized XML-based message format.
        - Server-based hub-and-spoke model.
        - Out-of-the-box features for messaging platforms.

    XMPP vs WebSockets :
        Similar Use Case: Both are good for real-time text-based communication like chat apps.
        Main Difference:
            - XMPP is a full protocol with features like presence, message archiving, and federation.
            - WebSocket is just a transport layer ‚Äì you must build presence, message queues, and formats yourself.
            - Use XMPP if you want a ready-made, standard protocol for messaging with robust features.
            - Use WebSocket if you need flexibility and are building a custom lightweight real-time system.

19. Activity Lifecycle on Orientation Change (Default)
    By default, changing the orientation (e.g., Portrait ‚Üí Landscape) causes the Activity
    to be destroyed and immediately recreated to load new configuration resources.

    -- Old Activity Instance (Destroyed)

        The system calls:

            onPause()

            onSaveInstanceState(Bundle) ‚Üê Crucial for saving dynamic state!

            onStop()

            onDestroy()

    -- New Activity Instance (Created)

        The system immediately calls:

            onCreate(Bundle) ‚Üê Use the Bundle here to restore saved state.

            onStart()

            onResume()

22. SSL pinning in android apps?
    SSL Pinning (or Certificate Pinning) is a security mechanism implemented within a client application,
    such as an Android app, to prevent Man-in-the-Middle (MITM) attacks by ensuring that the application
    only communicates with the expected server.
    In essence, instead of relying solely on the device's list of trusted Certificate Authorities (CAs),
    the application pre-stores, or "pins," the expected public key or the server's leaf certificate
    directly within its codebase.

    There are two primary ways to implement SSL Pinning in an Android application:

    -- Certificate Pinning (Pinning the Leaf Certificate)

        The application includes the full leaf certificate of the server.
        During the connection, the app checks if the server's presented certificate is an
        exact match for the pinned certificate.

    -- Public Key Pinning (The Recommended Method)

        The application includes the public key hash extracted from the server's certificate.
        During the connection, the app extracts the public key from the server's presented certificate
        and compares its hash to the pinned hash.

23. HTTP protocols - GET,POST,PUT,DELETE

    1. GET ‚Äî Fetch Data :
        - Used to retrieve data from the server.
        - When you only need to read data.
        - No change happens on the server.

        Query Params: YES ‚ûú ?page=1&sort=asc
        Path Params: YES ‚ûú /users/12
        Headers: YES
        Body params: No-body allowed

    2. POST ‚Äî Create New Data
        - Used to create a new resource on the server.
        - Submitting a form
        - Creating a post, comment, new entry

        Body Params: YES (main usage)
        Headers: YES
        Query Params: YES (optional)
        Path Params: YES
        Body Type: JSON, form-data, multipart (upload image)

    3. PUT ‚Äî Update Entire Resource
        - Updates an existing resource, usually replaces the entire object.
        - You want to update the full object
        - All fields must be sent, even if only 1 changed

        @PUT("users/{id}")
        suspend fun updateUser(
            @Path("id") id: Int,
            @Body user: UserUpdateRequest
        ): UserResponse

        Body Params: YES
        Headers: YES
        Path/Query Params: YES
        Body Type: JSON (commonly)

    4. PATCH ‚Äî Update Partial Resource
        - Updates part of the resource, NOT the whole thing.
        - Updating only specific fields
        - More efficient than PUT

        @PATCH("users/{id}")
        suspend fun updateUserName(
            @Path("id") id: Int,
            @Body map: Map<String, Any>
        ): UserResponse

        Body Params: YES (partial object)
        Headers: YES
        Path/Query Params: YES

    5. DELETE ‚Äî Remove Data

        - Used to delete a resource from the server.

        @DELETE("users/{id}")
        suspend fun deleteUser(@Path("id") id: Int): Response<Unit>

        Path Params: YES
        Query Params: YES
        Headers: YES

24. Project level build.gradle vs app level build.gradle ?

    Project Level :
        Global build configuration
        Repositories used by all modules
        Gradle plugin versions
        Classpath dependencies (old Gradle versions)

        This file tells the entire project:
            where to fetch dependencies from
            which gradle plugin version to use
            configurations shared across all modules

    App Level :
        Everything related to building the actual Android app, like:
        - Android SDK versions
        - Dependencies required by ONLY this app
        - Build types: debug/release
        - Product flavors

25. How do you share data between fragments,(using NavGraph also) ?

    1. Shared ViewModel (Recommended & Most Used ‚Äî with NavGraph / Activity scope) :

        class SharedViewModel : ViewModel() {
            val name = MutableLiveData<String>()
        }

        private val vm: SharedViewModel by activityViewModels()
        vm.name.value = "Samriddha"

        private val vm: SharedViewModel by activityViewModels()
        vm.name.observe(viewLifecycleOwner) {
            binding.txtName.text = it
        }

    2. Passing data using Safe Args (Navigation Component) :
        For one-directional passing (Fragment A ‚Üí Fragment B).

        In nav_graph.xml
            <fragment
                android:id="@+id/detailsFragment"
                android:name="com.example.DetailsFragment">
                <argument
                    android:name="userId"
                    app:argType="string" />
            </fragment>

        Fragment A
            val action = HomeFragmentDirections
                .actionHomeToDetails(userId = "12345")

            findNavController().navigate(action)

        Fragment B
            private val args: DetailsFragmentArgs by navArgs()
            val userId = args.userId
